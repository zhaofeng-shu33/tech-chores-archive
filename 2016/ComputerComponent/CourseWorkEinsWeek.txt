1.a 10001110111011111100000000000000 为1个32位的有符号整数，换算成10进制为-189689038;
1.b 若这个32位的数据表示一个无符号整数，则表示2398076928(10进制)
1.c 若这个32位数据表示一个单精度浮点数，可写一个C语言程序格式化输出它的十进制的指数表示为-5.910294E-30,其中最高位为符号位，中间8位为2的指数位，后面32位为有效数字位。 

2 用printf("%x",*(int*)(&float_number));可以实现。
先把float_number转为32位的整形，利用%x可以格式化输出整数即可实现。
但把float_number转为32位的整形要借助指针操作。

3.根据Block Code的概念，Hamming code 若有k位message code,r位 check code,总的block length n=k+r,而pow(2,r)=k+r+1,--> n=pow(2,r)-1
-->'wasted bits' percentage=r/(pow(2,r)-1),
for r=3,4,5,6,this percentage=43%,27%,16%,9.5%.
4. 0000 0001 1001 0101
5. 1111 1111 1011 1100
6 先将x,y用5位补码表示，最高位为符号位，x=0b01110,y=0b11011,
.a 原码的乘法先将补码转为原码绝对值，abs(x)=0b01110,abs(y)=0b00101
再进行原码的正数乘法。用一个5位的被乘数寄存器存储abs(x),10位的部分积寄存器存储积和乘数：
00000 00101
取最低位，为1，被乘数加到部分积前5位上
01110 00101
移位
00111 00010
取最低位，为0，部分积不变
移位
00011 10001
取最低位，为1，被乘数加到部分积前5位上
10001 10001
移位
01000 11000
...（一共移位5次）
得结果
00010 00110
比较乘数和被乘数补码表示的最高位，确定乘积补码表示的最高位为乘数和被乘数补码表示的最高位的亦或。
该乘积得负，最高位为1.
结果转化为补码表示为：
1110111010
.b用Booth Algorithm 计算同样的算术表达式:
x=0b01110,y=0b11011
00000 11011
乘数y最低一位补0,最低一位和附加位为10，部分积减去被乘数，得:
10010 11011（0）
移位
11001 01101（1）
最低一位和附加位为11，部分积不变，移位得:
11100 10110（1）
最低一位和附加位为01，部分积加上被乘数，得：
01010 10110，移位得：
00101 01011（0），最低一位和附加位为10，部分积减去被乘数，得:
10111 01011，右移两位得:
11101 11010,此即为最终结果。
和6.a计算结果一致。

x=0.10110000,y=-0.1101,
x/y作原码除法，将无符号整数01011 00000与01101相除，小数点固定在倒数第4位
01011<01101 首位商0
左移,最右端补商0：
10110 0000(0)
10110>01101,次位商1，（实际硬件并不做比较，而是直接试减，若结果为负，再加上01101，以便统一处理，因此该方法也被称之为恢复余数法）
10110-01101=01001
01001 0000（0）
再左移，最右端补商1，
10010 000(01)
10010>01101,第三位商1
10010-01101=00101
00101 000(01)
左移,最右端补商1：
01010 00(011)
01010<01101,第四位商0，
左移，最右端补商0
10100 0（0110）
10100>01101,第五位商1，
得商为01101，加上小数点为0.1101,考虑符号后为-0.1101.

用不恢复余数的方法计算01011 00000/01101
01011-01101=01011+10011=11110，商0，
左移一位 11100 0000（0）最右端补商0
因为上次减运算结果为负，本次应+01101且商1
01001 0000（0）
左移一位，最右端补商1
10010 000（01）
10010-01101=10010+10011=00101，商1
左移一位，01010 00（011），最右端补商1
因为上次减运算结果为正，本次应-01101
01010-01101=01010+10011=11101，商0
左移一位 11010 0（0110）最右端补商0
因为上次减运算结果为负，本次应+01101且商1
11010+01101=00111，左移一位
01110 （01101）
商01101
余数01110
偏移后
商0.1101，注意是二进制的小数点
余数0.1110
直接用补码除法实现x/y
其中x=0.10110000,y=-0.1101,
将有符号整数01011 00000（x补）与10011（y补）相除，小数点固定在倒数第4位
第一次做除，先判断两数的符号，为异号，应做加法运算：
01011+10011=11110，余数与10011同号，商1（作为商的最高位，表示商为负数）
左移一位 11100 0000（1）最右端补商1
上次同号，作减求下位商，
11100-10011=01001，余数与10011异号，商0
左移一位，10010 000（10），最右端补商0
上次异号，作加求下位商
10010+10011=00101，余数与10011异号，商0
左移一位，01010 00（100）
上次异号，作加求下位商
01010+10011=11100，余数与10011同号，商1
左移一位，11000 0（1001）
因为商是用反码表示的，采用末尾恒置1的方法对商进行修正，得到补码商为10010,即表示-0.1101
6.c x(原)=1110,y(原)=0101
求1110 0000/00101，
1110-0101=1001，为正，商1，
左移一位
0010 000（1），最右端补商1
0010-0101=1101，为负，商0
左移一位，1010 00（10）
因上次减运算结果为负，本次应+0101
1010+0101=1111,商1
左移1位，1110 0（101）
1110-0101=1001，商1
左移一位0010 (1011)
-> 结果为商，根据实际情况小数点应在倒数第二位，结果为负，所以为-10.11，用二进制原码表示为-010.11，十进制为-2.75，这是没有除尽的结果。
二进制无法用有限的位数表示出十进制的精确解-2.8.
