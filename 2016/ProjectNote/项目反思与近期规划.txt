关于项目底层工作的回顾与反思：
看了你的开题报告的时间节点，短期到7月底，实现软件XXX,数据XXX,算法XXX,
我最近想看一点fuzzy searching algorithm,无奈没有所谓的标准教科书，只好先从精确匹配算法一点点学起。如果这方面你能胜任的话我们可以再讨论。
出于专业背景，最近几天主要在做优化算法方面的编程，由于频繁使用c++的第三方类库，再加上之前处理字符编码的一些体会，对项目本身的底层工作有一些新的看法：
数据方面这里先略过，因为这方面的看法最近几个月没有太大改变，数据与程序分离。
主要说一下词典类，我们最初讨论的时候，都知道C++ 面向对象而更多地关注类继承和变位函数之类，这些高级功能需要有string已经实现的函数的支持。但是string提供的操作是不太够的，Qt中的QString用起来很方便，除unicode支持外，它的方法极大扩展了string,我之前用到的大概有：正则表达式、string split、convert to other data types、 取子串等。但由于最近一直在DevC++下编程，出于想从文件读字符串转换成double的原因，发现QString用不了，从而发现了原生string真的缺少一些可能会经常用到的底层方法，而这些方法可能会构成项目本身编程方面的基础。
虽然QString提供的函数基本能满足需要，但我想还是有必要自己亲自体验一下基于string(char*) 实现我们要用到的method,这对正确理解和使用QString也会很有帮助。
首当其冲的是unicode支持的模块，尽管我在这方面之前已经花了大量的时间，但同样由于没有标准教科书，所知道的很不系统，而且隐隐觉得这和windows operating system会有关系，而windows编程又是很难学的。我想这个问题可以慢慢解决，比如可以学一点win32 编程，其控制台和应用程序输出终端，然后学习Unicode Support 模块。
但实现一个类本身的Unicode表示和操作系统应该没什么关系，要做的是把gb2312或utf-8或ascii编码的输入（string)在这个类中统一用unicode(utf-16)表示(decoding过程)，事实上只有utf-8或utf-16支持Umlaut，而网页采用是utf-8，这二者在中文表示上有一些不同，在Umlaut方面也不一样，如o上加两点Unicode码为00f6,而utf-8为c3b6。然后输出时这个类可以以不同的编码方式输出(encoding),事实上
gb2312和ascii编码方式无法编码Umlaut,以这种方式输出肯定会乱码。在Python str或Qt QString中这个模块是有的，我们通过自己实现一遍以更好地理解编码问题。这个应该不太困难。
有了上面的模块保证编码，可以扩展string类的（输入）输出方法，由于输入输出终端和操作系统关系密切，我们可以以读写文件的方式先绕开，我想输入方面能否解决在中文和德文字符混合输入（读utf-8)文件的情况下能正确的processing，这其中的困难在于中文3个字节，Umlaut2个字节，ascii一个字节。当然，为了处理方便，也可以把输入输出文件都存成Unicode编码，但为了使扩展的string类能应对更多的情况，事实上可以考虑处理gb2312(txt默认保存的类型） unicode 和utf-8（后二者是根据BOM(Byte Order Mark)即16进制打开txt的前2个或3个字符来识别的，在参考现有的第三方文件读取方面的c/c++函数类的条件下（很可能看不懂）自己实现以二进制读取文件，也不必考虑最广泛的情况（比如读取浮点数），就假定读取的文件可能是以上三种编码的中德文混合的情况，这其中为了实现utf-8到unicode的编码转换，需要分离出哪些是中文的utf-8码（3个字节），哪些是Umlaut的utf-8码（2个字节），哪些是ascii的，这一步可能是整个输入方法中最困难的地方，可能要有专门的算法，也许要利用数据库事先存储要查的编码。
输出方法比较容易，unicode固定每个字符2个字节，很容易切分转成（encoding)其他的编码方式写到文件中去。
因此自己实现的方法是基于unicode表示的字符串，这样原来的string的方法就要全部在unicode上实现一遍，比如一个(oe)ffnen 6个字符的字符串，每一个字符单元都用两位的unicode编码，这样st[0]直接取出Umlaut (oe),而
打开 是2个字符的字符串，同样每一个字符单元都用两位的unicode编码，这样st[0]直接取出“打”这个字。在Qt中QString的基本单位是QChar,而一个QChar就是两位的unicode编码的一个字符，用QChar的.unicode方法可以查看该字符的十进制编码。我之前虽然用string正确输出过中德混合字符串，但string类的表示下 一个Umlaut或中文字符会占用2个位置，这样单独输出st[0]很可能会乱码，而且很不方便检索，毕竟一个有意义的字符用两个基本单位来表示（据说windows下提供wchar支持unicode,似乎在c/c++可以直接用，由于源代码的编码方式、输出终端受限，我还没搞明白这方面的内容。另外Latin1方式用一个字节编码Latin 字母，虽然覆盖了Umlaut，但不可能支持中文，这样后续processing 汉语查询不可能。）
有了输入输出的方法类并基于一个字符单元是unicode（类似QChar或python中的unicode字符串的构成单位）重新实现最基本的字符串操作函数，如比较（给出匹配程度的结果，仅限于Latin字母，用于后面的单词fuzzy 查找算法）赋值，取子串，获得长度，获取unicode编码等（这些操作和算法没啥关系），每一个函数都要有相应的出错处理。之后可以专注于.find函数的实现，如果有了find,.findall和.substitute也很容易。
但关键是find函数的实现，应该有一个参数指定是exact 还是fuzzy,这里我其实并不清楚，一个字符串查找子串和单词列表查找match是不是等价，但二者应该有相似之处。对于fuzzy search，首先要定义好editing distance,然后设计一个计算两个单词编辑距离的函数，d=0为exact match,brute force的算法是把单词表跑一遍，根据fuzzy search 指定的tolerance d<n返回所有d小于n的单词（有d=0的则只会有一个），可以根据d的大小简单排个序。这样算法方面不得不做的工作就是editing distance计算函数了，